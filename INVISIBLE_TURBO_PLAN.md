# خطة التهجين الداخلي (The Invisible Turbo)

## 1) تسريع التحقق والبيانات (Rust تحت الغطاء)
- أنت تستخدم `pydantic==2.9.1` المكتوبة بـ Rust؛ استمر في الاعتماد عليها كمسار رئيسي للتحقق.
- استبدل `pandas` بـ `polars` لمعالجة البيانات الثقيلة (أسرع 10-50x) مع تحديث الأكواد المتأثرة تدريجيًا.
- استخدم `orjson` (الموجودة بالفعل في المتطلبات) كخيار serialization الافتراضي في الـ API responses بدل `json` القياسي.

## 2) فصل الجهاز العصبي (Real-time Go)
- احتفظ بكل منطق المستخدمين/المنشورات/القاعدة في FastAPI.
- أنشئ خدمة Go صغيرة مسؤولة فقط عن WebSockets (شات/إشعارات).
- التواصل عبر Redis: FastAPI يحفظ الحدث ثم يرسل إشارة إلى خدمة Go لتبث التحديثات فورًا مع استهلاك ذاكرة منخفض.

## 3) تحويل محرك الذكاء الاصطناعي إلى ONNX
- حوّل نموذج `bert-base-arabertv02` المستخدم في `amenhotep.py` إلى صيغة ONNX.
- شغل النموذج داخل بايثون باستخدام ONNX Runtime (محرك C++ سريع) بدل التشغيل المباشر عبر PyTorch.
- الهدف: خفض زمن الاستجابة 2x-5x بدون تغيير واجهة الاستخدام.

## 4) نقل الحسابات الرياضية الثقيلة إلى Rust
- في `app/modules/social/economy_service.py` ومع أي خوارزميات تغذية مستقبلية: اكتب الحسابات المكثفة بلغة Rust.
- استخدم PyO3 لبناء امتداد بايثون (مثل `my_fast_algo`) واستدعِه من الخدمة الحالية.
- النتيجة: سرعة حساب عالية مع بقاء التحكم ومنطق التدفق داخل بايثون.
